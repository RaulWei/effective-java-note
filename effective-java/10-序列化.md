# 10-序列化

---

- [第74条：谨慎地实现Serializable接口](#第74条谨慎地实现serializable接口)
- [第75条：考虑使用自定义的序列化形式](#第75条考虑使用自定义的序列化形式)
- [第76条：保护性地编写readObject方法](#第76条保护性地编写readobject方法)
- [第77条：对于实例控制，枚举类型优先于readResolve](#第77条对于实例控制枚举类型优先于readresolve)

---

## 第74条：谨慎地实现Serializable接口

实现`Serializable`接口付出的代价
1. 一旦该类被发布，大大降低了**改变该类实现**的灵活性！因为实现了`Serializable`，其序列化形式变成导出API的一部分
2. 增加了**安全漏洞**的可能性！**反序列化**容易忘记建立对象约束关系
3. 随着类发行新版本，相关**测试负担**增加！测试新版序列化旧版反序列化，测试旧版序列化新版反序列化

## 第75条：考虑使用自定义的序列化形式

当你决定将一个类做成可序列化的时候，请仔细考虑应该采用什么样的序列化形式，一旦序列化形式确定，**必须**被永久保留下去，以确保序列化**兼容性**！理想的序列化形式应该只包含对象所表示的**逻辑数据**，而**逻辑数据**和**物理表示法**应该各自独立！只有默认序列化形式能合理描述对象**逻辑状态**时，才能使用默认序列化形式，否则就要设计一个自定义序列化形式！

当对象物理表示法和逻辑数据有实质性区别时，使用默认序列化形式会有4个缺点
1. 它使该类的导出API永远束缚在类的内部表示法上
2. 消耗过多空间
3. 消耗过多时间
4. 引起**栈溢出**，默认序列化过程要对对象图执行一次递归遍历

`transient`修饰符表示这个实例域将从一个类的默认序列化形式中省略掉！无论你是否使用默认序列化形式，当`defaultWriteObject`方法被调用的时候，每个未被标记为`transient`的实例域都会被序列化！

不管使用哪种序列化形式，都要为每个可序列化的类声明一个**显式序列版本**！如果修改一个没有序列版本的现有类，希望新版能接受现有序列化实例，必须使用`serialver`工具自动为旧版本生成的值作为序列版本！如果想为类生成一个新版本，与现有不兼容，只需修改序列版本值！

## 第76条：保护性地编写readObject方法

反序列化机制是一个**隐藏的构造器**，`readObject`方法实际上相当于另一个**公有构造器**，必须检查参数有效性，必要时对参数进行保护性拷贝！

编写更健壮的`readObject`方法的指导方针
1. 对于**对象引用域必须保持私有**的类，要**保护性拷贝**这些域中的每个对象
2. 对于**任何约束条件**，若检查失败就抛`InvalidObjectException`异常，检查应跟在**所有保护性拷贝后**，**针对拷贝后对象**
3. 如果整个对象图被反序列化后必须进行验证，就应该使用`ObjectInputValidation`接口
4. 无论直接还是间接方式，都**不要调用类中任何可被覆盖的方法**，同构造器，多态机制可能调用子类覆盖方法导致失败

## 第77条：对于实例控制，枚举类型优先于readResolve

对于一个**正在被反序列化的对象**，如果它的类定义了正确声明的`readResolve`，那么在反序列化**后**，新建对象上的`readResolve`方法就会被调用，该方法返回的对象引用将被返回，**取代**新建的对象！

如果依赖`readResolve`进行**实例控制**，带有对象引用类型的**所有实例域**都必须声明为`transient`，否则，**攻击者**可能在`readResolve`运行前，**保护**指向反序列化对象的引用！

尽可能使用**枚举类型**来实施实例控制的约束条件！你将一个可序列化的实例受控的类编写成枚举，就可以**绝对保证**除了所声明的常量以外，不会有别的实例！