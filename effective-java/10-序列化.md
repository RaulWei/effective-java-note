# 10-序列化

---

- [第74条：谨慎地实现Serializable接口](#第74条谨慎地实现serializable接口)
- [第75条：考虑使用自定义的序列化形式](#第75条考虑使用自定义的序列化形式)

---

## 第74条：谨慎地实现Serializable接口

实现`Serializable`接口付出的代价
1. 一旦该类被发布，大大降低了**改变该类实现**的灵活性！因为实现了`Serializable`，其序列化形式变成导出API的一部分
2. 增加了**安全漏洞**的可能性！反序列化容易忘记建立对象约束关系
3. 随着类发行新版本，相关**测试负担**增加！测试新版序列化旧版反序列化，测试旧版序列化新版反序列化

## 第75条：考虑使用自定义的序列化形式

当你决定将一个类做成可序列化的时候，请仔细考虑应该采用什么样的序列化形式，一旦序列化形式确定，**必须**被永久保留下去，以确保序列化**兼容性**！理想的序列化形式应该只包含对象所表示的**逻辑数据**，而**逻辑数据**和**物理表示法**应该各自独立！只有默认序列化形式能合理描述对象**逻辑状态**时，才能使用默认序列化形式，否则就要设计一个自定义序列化形式！

当对象物理表示法和逻辑数据有实质性区别时，使用默认序列化形式会有4个缺点
1. 它使该类的导出API永远束缚在类的内部表示法上
2. 消耗过多空间
3. 消耗过多时间
4. 引起**栈溢出**，默认序列化过程要对对象图执行一次递归遍历

`transient`修饰符表示这个实例域将从一个类的默认序列化形式中省略掉！无论你是否使用默认序列化形式，当`defaultWriteObject`方法被调用的时候，每个未被标记为`transient`的实例域都会被序列化！

不管使用哪种序列化形式，都要为每个可序列化的类声明一个**显式序列版本**！如果希望新版能接受现有序列化实例，必须使用`serialver`工具自动为旧版本生成的值作为序列版本！