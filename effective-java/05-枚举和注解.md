# 05-枚举和注解

---

- [第31条：用实例域代替序数](#第31条用实例域代替序数)
- [第32条：用EnumSet代替位域](#第32条用enumset代替位域)

---

## 第31条：用实例域代替序数

**所有**枚举都有一个`ordinal`方法，它返回每个枚举常量在类型中的数字位置！看起来不错，维护起来是噩梦！

```Java
public enum Ensemble {
	SOLO, DUET, TRIO, QUARTET, QUINTET,
	SEXTET, SEPTET, OCTET, NONET, DECTET;

	public int numberOfMusicians() {
		return ordinal() + 1;
	}
}
// System.out.println(Ensemble.SEXTET.numberOfMusicians()) == 6
```

**永远不要**根据枚举的序数导出与它关联的值，而是要将它保存在一个**实例域**中！`ordinal`方法是设计成用于像`EnumSet`和`EnumMap`这种基于枚举的通用数据结构的，大多数时候最好完全**避免**使用它！

```Java
public enum Ensemble {
	SOLO(1), DUET(2), TRIO(3), QUARTET(4), QUINTET(5),
	SEXTET(6), SEPTET(7), OCTET(8), NONET(9), DECTET(10);

	private final int numberOfMusicians;
	Ensemble(int size) { this.numberOfMusicians = size; }
	public int numberOfMusicians() { return this.numberOfMusicians; }
}
```

## 第32条：用EnumSet代替位域

```Java
// int枚举模式的位域
public class Text {
	public static final int STYLE_BOLD = 1 << 0;
	public static final int STYLE_ITALIC = 1 << 1;
	public static final int STYLE_UNDERLINE = 1 << 2;
	public static final int STYLE_STRIKETHROUGH = 1 << 3;
	public void applyStyles(int styles) { ... }
}

// 客户端使用|进行union
text.applyStyles(STYLE_BOLD | STYLE_ITALIC);
```

`int`枚举模式位域的缺陷
1. 当位域以数字形式打印时，**翻译**位域比翻译简单`int`枚举常量困难
2. **遍历**位域表示的所有元素很困难

```Java
public class Text {
	public enum Style {
		BOLD, ITALIC, UNDERLINE, STRIKETHROUGH;
	}
	// styles用接口类型Set<Style>比EnumSet好
	public void applyStyles(Set<Style> styles) { ... }
}

// 客户端使用EnumSet，简洁，性能好
text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));
```

