# 01-创建和销毁对象

---

- [第1条：考虑用静态工厂方法代替构造器](#第1条：考虑用静态工厂方法代替构造器)
- [第2条：遇到多个构造器参数时要考虑用Builder](#第2条：遇到多个构造器参数时要考虑用Builder)

---

## 第1条：考虑用静态工厂方法代替构造器

静态工厂方法的优势
1. 有名称，可读性好
2. 不必每次调用都创建新对象，可重复利用
3. 可返回原返回类型的任何子类型的对象
4. 创建参数化类型的实例时，更简洁，__实际上，Java7开始已经支持泛型构造器类型推导，Java8再进化__

静态工厂方法的劣势
1. 类如果不含有public/protected构造器，就不能被子类化
2. 与其他静态方法实际上没有任何区别，不像构造器一样在API文档中有明确标识

静态工厂方法的惯用名
* valueOf - 返回实例与参数有相同的值，实际上是种类型转换方法
* of - valueOf的简洁替代
* getInstance - 返回实例是通过参数描述，对于Singleton来说，该方法无餐，并返回唯一实例
* newInstance - 与getInstance不同，该方法确保返回每个实例与其他实例不同

## 第2条：遇到多个构造器参数时要考虑用Builder

静态工厂和构造器共有局限：都不能很好地扩展到大量可选参数！

几种处理大量可选参数的构造模式
1. 重叠构造器模式，__安全，不易阅读和编写__
2. JavaBean模式，__易于阅读和编写，不安全__
3. Builder模式，__既安全，又易于阅读和编写__

### 重叠构造器模式

第一个构造器只包含必要参数，第二个构造器除必要参数外有1个可选参数，第三个构造器除必要参数外有2个可选参数，以此类推，创建实例时使用者根据需求选择参数列表最短的构造器，显然，很难用，__构造时一旦不小心颠倒参数顺序，编译器也不报错，但结果与预期不一致，不好调试！__

### JavaBean模式

先调用一个无参构造器创建对象，然后依次调用setter方法设置必要参数和可选参数，对于使用者倒是友好了，但是，__存在严重安全问题__，第一，构造过程被分到几个调用中，导致JavaBean可能处于__不一致__状态，第二，阻止类做成__不可变__的可能，因此，需要使用者__付出额外努力确保线程安全！__

### Builder模式