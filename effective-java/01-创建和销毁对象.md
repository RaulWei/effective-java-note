# 01-创建和销毁对象

---

- [第1条：考虑用静态工厂方法代替构造器](#第1条考虑用静态工厂方法代替构造器)
- [第2条：遇到多个构造器参数时要考虑用Builder](#第2条遇到多个构造器参数时要考虑用builder)
  - [Builder模式](#builder模式)
  - [重叠构造器模式](#重叠构造器模式)
  - [JavaBean模式](#javabean模式)
- [第3条：用私有构造器或枚举类型强化Singleton属性](#第3条用私有构造器或枚举类型强化singleton属性)
  - [公有静态final域](#公有静态final域)
  - [公有静态工厂方法](#公有静态工厂方法)
  - [单元素的枚举类型](#单元素的枚举类型)
- [第4条：通过私有构造器强化不可实例化的能力](#第4条通过私有构造器强化不可实例化的能力)
- [第5条：避免创建不必要的对象](#第5条避免创建不必要的对象)
- [第6条：消除过期的对象引用](#第6条消除过期的对象引用)
---

## 第1条：考虑用静态工厂方法代替构造器

静态工厂方法的优势
1. 有名称，可读性好
2. 不必每次调用都创建新对象，可重复利用
3. 可返回原返回类型的任何子类型的对象
4. 创建参数化类型的实例时，更简洁，__实际上，Java7开始已经支持泛型构造器类型推导，Java8再进化__

静态工厂方法的劣势
1. 类如果不含有public/protected构造器，就不能被子类化
2. 与其他静态方法实际上没有任何区别，不像构造器一样在API文档中有明确标识

静态工厂方法的惯用名
* valueOf - 返回实例与参数有相同的值，实际上是种类型转换方法
* of - valueOf的简洁替代
* getInstance - 返回实例是通过参数描述，对于Singleton来说，该方法无餐，并返回唯一实例
* newInstance - 与getInstance不同，该方法确保返回每个实例与其他实例不同

## 第2条：遇到多个构造器参数时要考虑用Builder

静态工厂和构造器共有局限：都不能很好地扩展到大量可选参数！

几种处理大量可选参数的构造模式
1. 重叠构造器模式，__安全，不易阅读和编写__
2. JavaBean模式，__易于阅读和编写，不安全__
3. Builder模式，__既安全，又易于阅读和编写__

### 重叠构造器模式

第一个构造器只包含必要参数，第二个构造器除必要参数外有1个可选参数，第三个构造器除必要参数外有2个可选参数，以此类推，创建实例时使用者根据需求选择参数列表最短的构造器，显然，很难用，__构造时一旦不小心颠倒参数顺序，编译器也不报错，但结果与预期不一致，不好调试！__

### JavaBean模式

先调用一个无参构造器创建对象，然后依次调用setter方法设置必要参数和可选参数，对于使用者倒是友好了，但是，__存在严重安全问题__，第一，构造过程被分到几个调用中，导致JavaBean可能处于**不一致**状态，第二，阻止类做成**不可变**的可能，因此，需要使用者**付出额外努力确保线程安全！**

### Builder模式

使用者首先根据必要参数构造一个builder对象，然后在builder上调用类似setter方法设置可选参数，最后调用无参的build方法生成**不可变对象**，注意，这个builder是它**构建的类的静态成员类**！算是某种最佳实践了，很亲切，我司撸Web项目在构造对象时也都是这么干的！

## 第3条：用私有构造器或枚举类型强化Singleton属性

实现Singleton的几种方法
1. 公有静态final域
2. 公有静态工厂方法
3. 单元素的枚举类型

### 公有静态final域

```Java
// Singleton with public final field
public class Elvis {
	public static final Elvis INSTANCE = new Elvis();
	private Elvis() { ... }
}
```

注意，使用者可能借助`AccessibleObject.setAccessible`方法，通过反射来调用私有构造器，为了抵抗这种攻击，可以修改构造器，使其被要求创建第二个实例时抛出异常！

### 公有静态工厂方法

```Java
// Singleton with static factory
public class Elvis {
	private static final Elvis INSTANCE = new Elvis();
	private Elvis() { ... }
	public static Elvis getInstance() = { return INSTANCE; }
}
```

公有静态工厂方法的优势在于**灵活性高**，在不改变API的前提下，容易改变方法的内部实现！

### 单元素的枚举类型

```Java
// Enum singleton
public enum Elvis {
	INSTANCE;
}
```

`公有静态final域`和`公有静态工厂方法`实现的Singleton变成可序列化时，仅在声明加上`implements Serializable`不够，还必须声明所有实例域为`transient`，并提供一个`readResolve`方法，否则，__每次反序列化一个序列化的实例都会创建一个新的实例！__

单元素枚举方法的优势在于**简洁**，并且**无偿提供序列化机制，绝对防止多次实例化**！它已成为实现Singleton的最佳方法！

## 第4条：通过私有构造器强化不可实例化的能力

有些类只包含静态方法和静态域，如`java.lang.Math`和`java.util.Arrays`等工具类，它们不希望被实例化。怎么办？做成抽象类？__行不通__！第一，抽象类可以被**子类化**，而子类可以被实例化，第二，容易**误导**用户，让人觉得这种类是专门**为了继承而设计**的！

靠谱的做法是**让这个类包含私有构造器**，这样编译器不会生成缺省构造器，并确保类中不调用该私有构造器，就行了！

```Java
public class Utility {
	// Suppress default constructor for noninstantiability
	private Utility() {
		throw new AssertionError();
	}
}
```

## 第5条：避免创建不必要的对象

如果可以，尽量重用对象，它比每次都创建相同功能的新对象高效！哪种对象可以重用？
1. **不可变**对象，即`immutable`对象
2. __已知不会被修改的可变对象__

常用重用实践
1. 静态初始化器，即`initializer` - 可通过`延迟初始化`优化
2. 优先使用基本类型，而不是装箱基本类型 - 当心**无意识的自动装箱**

注意，实际上现代JVM对于小对象的构造和回收很廉价，通常情况下创建新对象并无大碍，我们做到两点即可，第一，__避免在每次循环中创建不必要的对象__，第二，重用对象的**前提**是确保对象可重用，毕竟重用了不可重用对象会带来严重错误和安全漏洞，而创建不必要的新对象只影响性能！

## 第6条：消除过期的对象引用

如果一个对象引用被无意识地保留起来，垃圾回收**不仅**不会处理该对象，而且也不会处理**被这个对象引用的所有其他对象**！注意，只要类是自己管理内存，程序员就要警惕内存泄露！__一旦元素被释放，则元素中包含的任何对象引用都应该被清空！__

Java内存泄露常见来源
1. 自定义栈 - 应该**清空过期引用**
2. 缓存 - WeakHashMap？
3. 监听器和其他回调 - 弱引用？