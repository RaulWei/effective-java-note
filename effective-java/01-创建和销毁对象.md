# 01-创建和销毁对象

---

- [第1条：考虑用静态工厂方法代替构造器](#第1条考虑用静态工厂方法代替构造器)
- [第2条：遇到多个构造器参数时要考虑用Builder](#第2条遇到多个构造器参数时要考虑用builder)
  - [Builder模式](#builder模式)
  - [重叠构造器模式](#重叠构造器模式)
  - [JavaBean模式](#javabean模式)
- [第3条：用私有构造器或枚举类型强化Singleton属性](#第3条用私有构造器或枚举类型强化singleton属性)
  - [公有静态final域](#公有静态final域)
  - [公有静态工厂方法](#公有静态工厂方法)
  - [单元素的枚举类型](#单元素的枚举类型)

---

## 第1条：考虑用静态工厂方法代替构造器

静态工厂方法的优势
1. 有名称，可读性好
2. 不必每次调用都创建新对象，可重复利用
3. 可返回原返回类型的任何子类型的对象
4. 创建参数化类型的实例时，更简洁，__实际上，Java7开始已经支持泛型构造器类型推导，Java8再进化__

静态工厂方法的劣势
1. 类如果不含有public/protected构造器，就不能被子类化
2. 与其他静态方法实际上没有任何区别，不像构造器一样在API文档中有明确标识

静态工厂方法的惯用名
* valueOf - 返回实例与参数有相同的值，实际上是种类型转换方法
* of - valueOf的简洁替代
* getInstance - 返回实例是通过参数描述，对于Singleton来说，该方法无餐，并返回唯一实例
* newInstance - 与getInstance不同，该方法确保返回每个实例与其他实例不同

## 第2条：遇到多个构造器参数时要考虑用Builder

静态工厂和构造器共有局限：都不能很好地扩展到大量可选参数！

几种处理大量可选参数的构造模式
1. 重叠构造器模式，__安全，不易阅读和编写__
2. JavaBean模式，__易于阅读和编写，不安全__
3. Builder模式，__既安全，又易于阅读和编写__

### 重叠构造器模式

第一个构造器只包含必要参数，第二个构造器除必要参数外有1个可选参数，第三个构造器除必要参数外有2个可选参数，以此类推，创建实例时使用者根据需求选择参数列表最短的构造器，显然，很难用，__构造时一旦不小心颠倒参数顺序，编译器也不报错，但结果与预期不一致，不好调试！__

### JavaBean模式

先调用一个无参构造器创建对象，然后依次调用setter方法设置必要参数和可选参数，对于使用者倒是友好了，但是，__存在严重安全问题__，第一，构造过程被分到几个调用中，导致JavaBean可能处于**不一致**状态，第二，阻止类做成**不可变**的可能，因此，需要使用者**付出额外努力确保线程安全！**

### Builder模式

使用者首先根据必要参数构造一个builder对象，然后在builder上调用类似setter方法设置可选参数，最后调用无参的build方法生成**不可变对象**，注意，这个builder是它**构建的类的静态成员类**！算是某种最佳实践了，很亲切，我司撸Web项目在构造对象时也都是这么干的！

## 第3条：用私有构造器或枚举类型强化Singleton属性

实现Singleton的几种方法
1. 公有静态final域
2. 公有静态工厂方法
3. 单元素的枚举类型

### 公有静态final域

```Java
// Singleton with public final field
public class Elvis {
	public static final Elvis INSTANCE = new Elvis();
	private Elvis() { ... }
}
```

注意，使用者可能借助`AccessibleObject.setAccessible`方法，通过反射来调用私有构造器，为了抵抗这种攻击，可以修改构造器，使其被要求创建第二个实例时抛出异常！

### 公有静态工厂方法

```Java
// Singleton with static factory
public class Elvis {
	private static final Elvis INSTANCE = new Elvis();
	private Elvis() { ... }
	public static Elvis getInstance() = { return INSTANCE; }
}
```

公有静态工厂方法的优势在于**灵活性高**，在不改变API的前提下，容易改变方法的内部实现！

### 单元素的枚举类型

```Java
// Enum singleton
public enum Elvis {
	INSTANCE;
}
```

`公有静态final域`和`公有静态工厂方法`实现的Singleton变成可序列化时，仅在声明加上`implements Serializable`不够，还必须声明所有实例域为`transient`，并提供一个`readResolve`方法，否则，__每次反序列化一个序列化的实例都会创建一个新的实例！__

单元素枚举方法的优势在于**简洁**，并且**无偿提供序列化机制，绝对防止多次实例化**！它已成为实现Singleton的最佳方法！