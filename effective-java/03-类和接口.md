# 03-类和接口

---

- [第13条：使类和成员的可访问性最小化](#第13条使类和成员的可访问性最小化)
- [第14条：在公有类中使用访问方法而非公有域](#第14条在公有类中使用访问方法而非公有域)
- [第15条：使可变性最小化](#第15条使可变性最小化)
- [第16条：复合优先于继承](#第16条复合优先于继承)
- [第19条：接口只用于定义类型](#第19条接口只用于定义类型)
- [第22条：优先考虑静态成员类](#第22条优先考虑静态成员类)
  - [静态成员类](#静态成员类)
  - [非静态成员类](#非静态成员类)
  - [匿名类](#匿名类)
  - [局部类](#局部类)

---

## 第13条：使类和成员的可访问性最小化

信息隐藏：模块之间只通过API通信，模块不需要知道其他模块内部工作情况！有效解除组成系统的各个模块间的耦合关系，使得模块可以独立开发、测试、优化、使用、理解和修改！

信息隐藏的优势
1. 加快系统开发速度，因为模块可以**并行开发**
2. 有效**调节性能**，通过剖析确定哪些模块影响系统性能，那些模块可进一步优化，不影响其他模块正确性

成员（域、方法、嵌套类、嵌套接口）的四种访问级别
1. 私有`private` - 只有声明该成员的**顶层类内部**才能访问该成员
2. 包级私有`package-private` - __缺省访问级别__，声明该成员的**包内部任何类**都能访问该成员
3. 受保护`protected` - 声明该成员的**包内部任何类**及声明该成员的类的**子类**能访问该成员
4. 公有`public` - 任何地方都能访问该成员

对于**顶层即非嵌套的类和接口**，只有两种访问级别：包级私有和公有！如果声明为包级私有，说明它是包的**实现**的一部分，后续发行版本可对其进行修改、替换或删除！如果声明为公有，说明它是包**导出API**的一部分，有责任**永远**支持它，保持**兼容**！

注意，__如果子类覆盖超类中的某个方法，子类的访问级别不能低于超类的访问级别__！这样可确保**任何使用超类实例的地方都能使用子类实例**！接口的所有方法都**隐含公有**访问级别，因此**接口实现类的所有方法都必须声明为公有**！

注意，**包含公有可变域的类并不是线程安全的**！例外是**公有静态final域暴露常量**，要么包含**基本类型**值，要么包含**指向不可变对象的引用**！如果类具有**公有静态final数组域**，或者**返回**这种域的访问方法，几乎是**错误**的！解决方案是将**公有数组变私有**，**增加公有不可变列表**或者**添加公有方法返回私有数组的备份**！

```Java
private static final Thing[] PRIVATE_VALUES = { ... };
// 1. 增加公有不可变列表
public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
// 2. 添加公有方法返回数组的备份
public static final vaules() {
	return PRIVATE_VALUES.clone();
}
```

## 第14条：在公有类中使用访问方法而非公有域

1. **公有类**不应该暴露**可变域**，因为其客户端代码遍布各处，将来极难改变内部表示法
2. **公有类**暴露**不可变域**危害较小，事实上也不应该
3. **包级私有**或**私有嵌套**类，直接暴露数据域并没有本质错误

## 第15条：使可变性最小化

不可变类是**实例不能被修改**的类，**所有**信息都必须在**创建**实例的时候就提供，并在对象的**整个生命周期内固定不变**！

为了使类成为不可变，要遵循以下规则
1. 不要提供任何会修改对象状态的方法
2. 保证类**不会被扩展**
3. 使所有域都是`final`
4. 使所有域都是`private`
5. 确保对于任何可变组件的**互斥访问**

不可变对象的优点
1. 简单，只有一种状态，即**被创建时的状态**
2. 线程安全，它们不要求同步，不需要**保护性拷贝**，不用提供**拷贝构造器**或`clone`方法
3. 不仅可以共享不可变对象，还能共享**内部信息**
4. 为其他对象**提供了大量构件**

不可变对象唯一的缺点是，对于**每个不同的值**都需要**一个单独的对象**，在特定情况下存在潜在的性能问题！解决方案可以为它提供**可变配套类**，如`String`对应的`StringBuilder`！

注意，如果类**不能被做成**不可变，仍然应该**尽可能限制**它的可变性，降低对象可以存在的状态数！构造器应该创建**完全初始化**的对象，并建立**所有的约束关系**，不要在构造器或静态工厂之外再提供公有的初始化方法，除非有足够的理由！

## 第16条：复合优先于继承

在**包内部**使用继承是安全的，因为子类和超类的实现都处在同一个程序员的控制下，**跨越包边界**的继承是危险的！
1. 继承打破了**封装性**，即子类覆盖方法时可能依赖超类特定功能的**实现细节**，则必须跟随超类更新而演变，可这无法保证
2. 超类在后续版本可能获得新方法，例如，假设子类覆盖超类所有插入相关方法进行插入前验证，如果后续超类又新增一个插入方法，子类未覆盖的话则可能将未验证的非法数据成功插入

更好的做法是复合，在新的类中增加一个**私有域**，它引用现有类的一个实例，即现有类变成新类的一个组件！涉及的概念有：**包装类**，**转发类**，**装饰器模式**！

决定使用继承而不是复合前，问自己两个问题
1. 二者是`is-a`关系吗
2. 试图扩展的类的API有缺陷吗，**继承会将超类API的所有缺陷传播到子类，复合则允许设计新API隐藏缺陷**


## 第19条：接口只用于定义类型

```Java
// 常量接口
public interface PhysicalConstants {
	static final double AVOGADROS_NUMBER = 6.0221499e23;
	static final double ELECTRON_MASS = 9.10938188e-31;
}
```

常量接口模式是对接口的**不良使用**，是反面典型，不值得效仿！关键原因：如果类实现常量接口，将来版本中类修改了，不需要这些常量了，它还依然**必须**实现这个接口，以确保**二进制兼容性**！所以说，接口应该只被用来**定义类型**，不应该被用来导出常量！

导出常量合理的方案：使用**不可实例化**的**工具类**配合**静态导入**！

```Java
// 定义常量类
package com.effectivejava.science;
public final class PhysicalConstants {
	private PhysicalConstants() {}
	public static final double AVOGADROS_NUMBER = 6.0221499e23;
	public static final double ELECTRON_MASS = 9.10938188e-31;
}

// 使用
import static com.effectivejava.science.PhysicalConstants.*;
public class Test {
	double atoms(double mols) {
		return mols * AVOGADROS_NUMBER;
	}
}
```

## 第22条：优先考虑静态成员类

**嵌套类**存在的目的**只是**为外围类提供服务，如果其将来可能用于其他环境，它就应该是**顶层类**！

嵌套类包括4种，后3种被称为**内部类**
1. 静态成员类
2. 非静态成员类
3. 匿名类
4. 局部类

### 静态成员类

最好把它看作是**普通**的类，它可以访问外围类的**所有**成员，**包括私有**成员！静态成员类是外围类的一个**静态成员**，和其他静态成员一样遵守**同样**的访问规则！

### 非静态成员类

非静态成员类的每个实例都隐含与外围类的一个外围实例相关联，即**每个非静态成员类实例**都包含一个额外的**指向外围实例的引用**！保存引用消耗非静态成员类实例的时间和空间！这种关联在非静态成员类实例被**创建**的时候建立，并且**不能**修改！注意，**没有**外围实例的情况下，创建非静态成员类实例是**不可能**的！

### 匿名类

匿名类是在**使用的同时**被声明和实例化！匿名类一般保持简短！匿名类常用作**动态创建函数对象**，**创建过程对象**和**在静态工厂方法内部使用**！

### 局部类

局部类用的最少，在**任何**可以声明局部变量的地方都可以声明局部类！它和**成员类**一样有名字，能被**重复**利用！它和**匿名类**一样**只有**在非静态环境中定义时才有外围实例，**不能**包含静态成员！