# 04-泛型

---

- [第23条：请不要在新代码中使用原生态类型](#第23条请不要在新代码中使用原生态类型)
- [第24条：消除非受检警告](#第24条消除非受检警告)

---

## 第23条：请不要在新代码中使用原生态类型

泛型类和接口统称**泛型**！每个泛型都定义一个**原生态类型**，即不带任何实际类型参数的泛型名称，与`List<E>`相对应的原生态类型是`List`！如果使用原生态类型，就失掉了泛型在**安全性**和**表述性**方面的所有优势！

为什么还允许使用原生态类型？这是为了提供**兼容性**！泛型出现的时候已经存在大量没使用泛型的代码，为了新旧代码能兼容互用，促成了支持原生态类型的决定！

不使用原生态类型`List`，却又想允许插入任意对象，可使用参数化类型`List<Object>`，前者**逃避**了类型检查，而后者是**明确告诉**编译器，它能够持有**任意**类型的对象！

```Java
// 出错最好早发现，编译时出错好过运行时出错
public static void main(String[] args) {
	List<String> strings = new ArrayList<>();
	// 测试以下两种传参方式的`unsafeAdd`
	unsafeAdd(strings, new Integer(42));
	String s = strings.get(0);
}

// 1. 虽有警告，但仍能成功将`42`插入`strings`，因为`List<String>`是`List`的子类型，而取出时抛`ClassCastException`
private static void unsafeAdd(List list, Object o) {
	list.add(o);
}
// 2. 无法编译，因为`List<String>`不是`List<Object>`的子类型
private static void unsafeAdd(List<Object> list, Object o) {
	list.add(o);
}
```

在不确定或者不在乎集合中的元素类型情况下，你也许会使用原生态类型，更安全的替代方法是**无限制的通配符类型**，如`Set<?>`，它表示只能包含**某种**未知对象类型的一个集合！相关的术语还有**有限制的通配符类型**，如`List<? extends Number>`，**有限制类型参数**，如`<E extends Number>`等！

需要使用原生态类型的**例外**，都和**泛型信息可以在运行时被擦除**有关
1. 在**类文字**中**必须**使用原生态类型，规范不允许使用参数化类型，如`List.class`合法，`List<String>.class`不合法
2. 在**参数化类型**上使用`instanceof`操作符是**非法**的，可使用**无限制通配符类型**，但此时`<?>`显得多余

## 第24条：消除非受检警告

非受检警告非常重要，**不要忽略**它们，每一条警告都表示可能在运行时抛出`ClassCastException`异常！要尽可能消除非受检警告，如果消除了所有警告，就能**确保**代码是类型安全的，能更加自信实现预期！

如果**无法消除**警告，**同时可以证明**引起警告的代码是类型安全的，就**该**用一个`@SuppressWarnings("unchecked")`注解来**禁止**这些警告！而**不是忽略**它，因为如果选择忽略，那么当新出现真正有问题的警告时，你也不会注意到！记住，要用**注释**把禁止该警告的原因记录下来！

要始终在**尽可能小范围**中使用`@SuppressWarings`注解，永远不要在整个类上使用`@SuppressWarings`注解！将`@SuppressWarings`注解放到`return`语句中是**非法**的，因为它**不是**一个**声明**，应该声明一个**局部变量**来保持返回值，并注解其声明！