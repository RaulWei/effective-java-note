# 04-泛型

---

- [第23条：请不要在新代码中使用原生态类型](#第23条请不要在新代码中使用原生态类型)


---

## 第23条：请不要在新代码中使用原生态类型

泛型类和接口统称**泛型**！每个泛型都定义一个**原生态类型**，即不带任何实际类型参数的泛型名称，与`List<E>`相对应的原生态类型是`List`！如果使用原生态类型，就失掉了泛型在**安全性**和**表述性**方面的所有优势！

为什么还允许使用原生态类型？这是为了提供**兼容性**！泛型出现的时候已经存在大量没使用泛型的代码，为了新旧代码能兼容互用，促成了支持原生态类型的决定！

不使用原生态类型`List`，却又想允许插入任意对象，可使用参数化类型`List<Object>`，前者**逃避**了类型检查，而后者是**明确告诉**编译器，它能够持有**任意**类型的对象！

```Java
// 出错最好早发现，编译时出错好过运行时出错
public static void main(String[] args) {
	List<String> strings = new ArrayList<>();
	// 测试以下两种传参方式的`unsafeAdd`
	unsafeAdd(strings, new Integer(42));
	String s = strings.get(0);
}

// 1. 虽有警告，但仍能成功将`42`插入`strings`，因为`List<String>`是`List`的子类型，而取出时抛`ClassCastException`
private static void unsafeAdd(List list, Object o) {
	list.add(o);
}
// 2. 无法编译，因为`List<String>`不是`List<Object>`的子类型
private static void unsafeAdd(List<Object> list, Object o) {
	list.add(o);
}
```

在不确定或者不在乎集合中的元素类型情况下，你也许会使用原生态类型，更安全的替代方法是**无限制的通配符类型**，如`Set<?>`，它表示只能包含**某种**未知对象类型的一个集合！相关的术语还有**有限制的通配符类型**，如`List<? extends Number>`，**有限制类型参数**，如`<E extends Number>`等！

需要使用原生态类型的**例外**，都和**泛型信息可以在运行时被擦除**有关
1. 在**类文字**中**必须**使用原生态类型，规范不允许使用参数化类型，如`List.class`合法，`List<String>.class`不合法
2. 在**参数化类型**上使用`instanceof`操作符是**非法**的，可使用**无限制通配符类型**，但此时`<?>`显得多余