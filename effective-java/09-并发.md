# 09-并发

---

- [第66条：同步访问共享的可变数据](#第66条同步访问共享的可变数据)
- [第67条：避免过度同步](#第67条：避免过度同步)
- [第68条：executor和task优先于线程](#第68条executor和task优先于线程)
- [第69条：并发工具优先于wait和notify](#第69条并发工具优先于wait和notify)
- [第70条：线程安全性的文档化](#第70条线程安全性的文档化)
- [第71条：慎用延迟初始化](#第71条慎用延迟初始化)
- [第72条：不要依赖于线程调度器](#第72条不要依赖于线程调度器)
- [第73条：避免使用线程组](#第73条避免使用线程组)

---

## 第66条：同步访问共享的可变数据

多个线程共享**可变数据**的时候，每个读或者写数据的线程都**必须**执行同步！同步`synchronized`不仅实现**互斥**，还能保证进入同步方法或代码块的每个线程都看到同一个锁保护的**之前所有的修改效果**！

Java语言规范保证读或写一个变量是原子的，除非变量类型是`long`或`double`！即使是原子性的，但是不保证一个线程写入的值对另一个线程是可见的，所以同步**仍然必要**！例如，第一个线程轮询一个`boolean`域，直到第二个线程改变其值，这个方法不可行！轮询代码会被**提升**即`hoisting`优化掉，造成**活性失败**！可以将那个域声明为`volatile`，它能保证**任何一个线程读取该域的时候都将看到最近刚写入的值**！但是使用`volatile`要小心，它并不保证域的读写是原子性！

## 第67条：避免过度同步

为了避免**死锁**和**数据破坏**，在一个被同步的区域内部不要调用**外来方法**，即设计成**要被覆盖的方法**，或者是**由客户端以函数对象形式提供的方法**！

## 第68条：executor和task优先于线程

* **轻载**服务器选择`Executors.newCachedThreadPool`，不需要配置，任务没有排成队列而是**直接**交给线程执行，没有线程可用就**创建**一个新线程
* **高负载**服务器选择`Executors.newFixedThreadPool`，提供包含固定线程数目的线程池
* 想最大限度**控制**线程池，选择`ThreadPoolExecutor`

你不仅应该尽量**不要编写自己的工作队列**，而且还应该尽量**不直接使用线程**！

## 第69条：并发工具优先于wait和notify

正确使用`wait`和`notify`比较困难，现在推荐使用更高级的并发工具来代替！

`java.util.concurrent`中3中高级并发工具
1. Executor Framework
2. Concurrent Collection，即并发集合，为标准集合接口提供高性能并发实现，内部自己管理同步，不可能排除并发活动
3. Synchronizer，即同步器，使线程能够等待另一个线程，常用有`CountDownLatch`和`Semaphore`

对于间歇式定时，优先使用`System.nanoTime`，而不是使用`System.currentTimeMills`，前者**不受系统实时时钟调整所影响**！

你可能需要维护使用了`wait`和`notify`的遗留代码
* `wait`方法被用来使线程等待某个条件，必须在**同步区域内部**被调用，这个同步区域将对象锁定在调用`wait`方法对象上
* 始终应该用`wait`循环模式来调用`wait`方法，**永远不要**在循环**外**调用`wait`，循环会在等待前后测试条件
* 一般优先使用`notifyAll`，而不是`notify`，如果使用`notify`请一定小心，以确保程序活性

## 第70条：线程安全性的文档化

线程安全性级别
1. **不可变的**，不需要外界同步
2. **无条件的线程安全**，类实例可变，但是有足够的内部同步，无需任何外部同步，如`ConcurrentHashMap`
3. **有条件的线程安全**，除了有些方法为进行安全的并发使用而需要外部同步外，其余和无条件线程安全相同
4. **非线程安全**，客户必须利用自己选择的外部同步包围每个方法调用，如`ArrayList`和`HashMap`
5. **线程对立的**，不能安全地被多个线程并发使用，极少

每个类都应该利用字斟句酌的说明或线程安全注解在文档中说明它的线程安全属性！**有条件的线程安全类**必须在文档中指明哪个方法调用序列需要外部同步，以及在执行这些序列的时候要获得哪把锁！**无条件线程安全类**应该考虑使用**私有锁对象**来代替同步的方法！

## 第71条：慎用延迟初始化

延迟初始化**降低**了初始化类或者创建实例的开销，**增加**了访问被延迟初始化的域的开销！

如果出于性能考虑而需要对**静态域**使用延迟初始化，就使用`lazy initialization holder class`模式！
```Java
// 类级内部类相当于其外部类的成员，只有在第一次被使用的时候才会被装载
private static class FieldHolder {
	// 类级内部类中的静态方法只能够引用外部类中的静态成员方法或者成员变量
	// 由静态初始化器（静态字段或static{}块）初始化数据时，JVM隐式执行同步不需要自己控制
	static final FieldType field = computeFieldValue();
}

static FieldType getField() {
	return FieldHolder.field;
}

private static FieldType computeFieldValue() {
	return new FieldType();
}
```

如果出于性能考虑而需要对**实例域**使用延迟初始化，就使用**双重检查模式**！
```Java
private volatile FieldType field;

FieldType getField() {
	// 使用局部变量result是确保field只在已经被初始化情况下读取一次，提升性能
	FieldType result = field;
	if (result == null) { 
		synchronized (this) {
			result = field;
			if (result == null) {
				field = result = computeFieldValue();
			}
		}
	}
	return result;
}

private static FieldType computeFieldValue() {
	return new FieldType();
}
```

## 第72条：不要依赖于线程调度器

不要让应用程序的正确性依赖于线程调度器，否则，结果得到的应用程序将既不健壮，也不具有**可移植性**！编写健壮的、响应良好的、可移植的多线程应用程序，最好的办法是确保**可运行线程平均数量不明显多于处理器数量**！

1. 不要依赖`Thread.yield`，更好的办法是**重新构造应用程序**，以减少可并发运行的线程数量
2. 不要依赖**线程优先级**，线程优先级是Java平台上最不可移植的特征了

## 第73条：避免使用线程组

线程组`ThreadGroup`没有提供太多有用功能，而且提供的功能大多还是有缺陷的，垃圾！忽略它，当它不存在！如果你正在设计的一个类需要**处理线程的**逻辑组**，应该使用**线程池**`executor`！