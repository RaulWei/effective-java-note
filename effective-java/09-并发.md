# 09-并发

---

- [第66条：同步访问共享的可变数据](#第66条同步访问共享的可变数据)
- [第67条：避免过度同步](#第67条：避免过度同步)
- [第68条：executor和task优先于线程](#第68条executor和task优先于线程)
- [第69条：并发工具优先于wait和notify](#第69条并发工具优先于wait和notify)

---

## 第66条：同步访问共享的可变数据

多个线程共享**可变数据**的时候，每个读或者写数据的线程都**必须**执行同步！同步`synchronized`不仅实现**互斥**，还能保证进入同步方法或代码块的每个线程都看到同一个锁保护的**之前所有的修改效果**！

Java语言规范保证读或写一个变量是原子的，除非变量类型是`long`或`double`！即使是原子性的，但是不保证一个线程写入的值对另一个线程是可见的，所以同步**仍然必要**！例如，第一个线程轮询一个`boolean`域，直到第二个线程改变其值，这个方法不可行！轮询代码会被**提升**即`hoisting`优化掉，造成**活性失败**！可以将那个域声明为`volatile`，它能保证**任何一个线程读取该域的时候都将看到最近刚写入的值**！但是使用`volatile`要小心，它并不保证域的读写是原子性！

## 第67条：避免过度同步

为了避免**死锁**和**数据破坏**，在一个被同步的区域内部不要调用**外来方法**，即设计成**要被覆盖的方法**，或者是**由客户端以函数对象形式提供的方法**！

## 第68条：executor和task优先于线程

* **轻载**服务器选择`Executors.newCachedThreadPool`，不需要配置，任务没有排成队列而是**直接**交给线程执行，没有线程可用就**创建**一个新线程
* **高负载**服务器选择`Executors.newFixedThreadPool`，提供包含固定线程数目的线程池
* 想最大限度**控制**线程池，选择`ThreadPoolExecutor`

你不仅应该尽量**不要编写自己的工作队列**，而且还应该尽量**不直接使用线程**！

## 第69条：并发工具优先于wait和notify

正确使用`wait`和`notify`比较困难，现在推荐使用更高级的并发工具来代替！

`java.util.concurrent`中3中高级并发工具
1. Executor Framework
2. Concurrent Collection，即并发集合，为标准集合接口提供高性能并发实现，内部自己管理同步，不可能排除并发活动
3. Synchronizer，即同步器，使线程能够等待另一个线程，常用有`CountDownLatch`和`Semaphore`

对于间歇式定时，优先使用`System.nanoTime`，而不是使用`System.currentTimeMills`，前者**不受系统实时时钟调整所影响**！

你可能需要维护使用了`wait`和`notify`的遗留代码
* `wait`方法被用来使线程等待某个条件，必须在**同步区域内部**被调用，这个同步区域将对象锁定在调用`wait`方法对象上
* 始终应该用`wait`循环模式来调用`wait`方法，**永远不要**在循环**外**调用`wait`，循环会在等待前后测试条件
* 一般优先使用`notifyAll`，而不是`notify`，如果使用`notify`请一定小心，以确保程序活性