# 09-并发

---

- [第66条：同步访问共享的可变数据](#第66条同步访问共享的可变数据)
- [第67条：避免过度同步](#第67条：避免过度同步)
- [第68条：executor和task优先于线程](#第68条executor和task优先于线程)

---

## 第66条：同步访问共享的可变数据

多个线程共享**可变数据**的时候，每个读或者写数据的线程都**必须**执行同步！同步`synchronized`不仅实现**互斥**，还能保证进入同步方法或代码块的每个线程都看到同一个锁保护的**之前所有的修改效果**！

Java语言规范保证读或写一个变量是原子的，除非变量类型是`long`或`double`！即使是原子性的，但是不保证一个线程写入的值对另一个线程是可见的，所以同步**仍然必要**！例如，第一个线程轮询一个`boolean`域，直到第二个线程改变其值，这个方法不可行！轮询代码会被**提升**即`hoisting`优化掉，造成**活性失败**！可以将那个域声明为`volatile`，它能保证**任何一个线程读取该域的时候都将看到最近刚写入的值**！但是使用`volatile`要小心，它并不保证域的读写是原子性！

## 第67条：避免过度同步

为了避免**死锁**和**数据破坏**，在一个被同步的区域内部不要调用**外来方法**，即设计成**要被覆盖的方法**，或者是**由客户端以函数对象形式提供的方法**！

## 第68条：executor和task优先于线程

* **轻载**服务器选择`Executors.newCachedThreadPool`，不需要配置，任务没有排成队列而是**直接**交给线程执行，没有线程可用就**创建**一个新线程
* **高负载**服务器选择`Executors.newFixedThreadPool`，提供包含固定线程数目的线程池
* 想最大限度**控制**线程池，选择`ThreadPoolExecutor`

你不仅应该尽量**不要编写自己的工作队列**，而且还应该尽量**不直接使用线程**！
