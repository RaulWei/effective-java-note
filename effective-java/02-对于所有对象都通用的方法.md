# 02-对于所有对象都通用的方法

---

- [第8条：覆盖equals时请遵守通用约定](#第8条覆盖equals时请遵守通用约定)
- [第9条：覆盖equals时总要覆盖hashCode](#第9条覆盖equals时总要覆盖hashcode)
- [第10条：始终要覆盖toString](#第10条始终要覆盖tostring)
- [第11条：谨慎地覆盖clone](#第11条谨慎地覆盖clone)
- [第12条：考虑实现Comparable接口](#第12条考虑实现comparable接口)

---

## 第8条：覆盖equals时请遵守通用约定

不需要覆盖`equals`的情况 
1. 不关心类是否提供了**逻辑相等**的测试功能 
2. 超类已经覆盖了`equals`，从超类继承的行为对于子类也合适 
3. 类是私有的或者包级私有的，**并且**你能确定它的`equals`方法永远不会被调用，若要覆盖，则可以重写`equals`抛出`AssertionError`以防它被意外调用

需要覆盖`equals`的情况
1. 类具有自己特有的**逻辑相等**概念，**不同于对象等同**概念
2. 超类还没有覆盖`equals`以实现期望行为

遵守覆盖`equals`的约定
1. 自反性 - 对象必须等于其自身
2. 对称性 - 任何两个对象对于它们是否相等的问题都必须保持一致，`Timestamp`违反了，不值得效仿
3. 传递性 - 如果对象A等于B，B等于C，那么A一定等于C
4. 一致性 - 相等的对象**永远**相等，不相等的对象**永远**不相等
5. 非空性 - 所有的对象都必须不等于`null`

注意，一旦违反`equals`约定，当**其他对象面对你的对象**时，你**完全不知道**这些对象的行为会如何！**无法**在扩展**可实例化**的类的同时，既增加新的值组件，又保留`equals`约定！可以在一个**抽象类**的子类中增加新的值组件，不会违反`equals`约定，因为抽象类不能实例化！

实现高质量`equals`方法的诀窍
1. 使用`==`操作符检查**参数是否为这个对象的引用**
2. 使用`instanceof`操作符检查**参数是否为正确类型**，通常正确类型是**指`equals`所在的类**
3. 把参数转换为正确类型，转换前有`instanceof`测试，转换必定成功
4. 对于类中的每个关键域，检查参数中的域是否与该对象中对应的域匹配
5. 编写完成`equals`后，自问**是否对称、传递、一致**，同时编写单元测试来检验
6. **不要将`equals`声明中的`Object`对象替换为其他类型**，那样就不是`Override`而是`Overload`

```Java
// 程序员花几个小时都搞不清为什么它不能正常工作
public boolean equals(MyClass o) { ... }

// 无法编译，能够防止上述错误
@Override public boolean equals(MyClass o) { ... }
```

## 第9条：覆盖equals时总要覆盖hashCode

* 程序**一次**执行期间，只要对象的`equals`比较用到的信息没有被修改，则对该对象调用多次`hashCode`都**必须返回同一值**
* 程序**多次**执行过程，每次执行返回的`hashCode`**可以不一致**
* 相等的对象必须有相等的散列码
* 不相等的对象**不一定**要产生不同的散列码，但是通常**倾向于**为不相等对象产生不相等的散列码

注意，如果一个类是**不可变**的，同时计算散列码开销也大，则可把散列码**缓存**在对象内部！**不要**试图从散列码计算中排除掉一个对象的关键部分来提高性能！

## 第10条：始终要覆盖toString

`java.lang.Object`提供了`toString`方法的一个实现：`类名 + '@' + 散列码无符号16进制表示`！

指定`toString`返回值格式的优势
* 可以被用作一种标准的、明确的、适合人阅读的对象表示法

指定`toString`返回值格式的劣势
* 程序员基于该格式实现诸多工作，如果将来版本修改了格式，则会破坏大量原先的代码和数据，**灵活性差**

注意，无论是否指定格式，都为`toString`返回值中包含的所有信息提供一种**编程式的访问途径**！如果没有，则会迫使程序员编写额外代码解析字符串，既**降低性能**，又容易**解析出错导致系统不稳定**！

## 第11条：谨慎地覆盖clone

`Object`的`clone`方法是**受保护的**！`Cloneable`接口**没有包含任何方法**！`Cloneable`改变了超类中受保护的方法的行为！对于实现了`Cloneable`的类，我们总是**希望**它提供一个功能适当的**公有**的`clone`方法！此方法**首先**调用`super.clone`，**然后修正**任何需要修正的域！

实现对象拷贝**更好**的办法
1. **拷贝构造器** - 唯一参数类型是包含该构造器的类，`public Yum(Yum yum);`
2. **拷贝工厂** - `public static Yum newInstance(Yum yum);`

## 第12条：考虑实现Comparable接口

`compareTo`方法是`Comparable`接口中**唯一**的方法，实现`Comparable`接口就表明它的实例具有内在的排序关系！包含`compareTo`方法的对象与指定对象比较，当该对象**小于、等于或者大于**指定对象时，分别返回一个**负整数、零或者正整数**！`compareTo`要满足**自反性、对称性和传递性**！

注意，比较整数基本类型域可使用关系操作符`<`和`>`，浮点域可使用`Double.compare`或者`Float.compare`！通常在`compareTo`中为了**简化**代码，会以两数**作差**表示比较大小的结果，这种方法有风险！记住**一个有符号的32位的整数还没有大到足以表达任意两个32位整数的差**！如一个很大的正整数减去一个很大负整数将会**溢出**，并返回一个负值，导致错误结果！