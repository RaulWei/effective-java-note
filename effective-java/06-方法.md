# 06-方法

---

- [第38条：检查参数的有效性](#第38条检查参数的有效性)
- [第39条：必要时进行保护性拷贝](#第39条必要时进行保护性拷贝)
- [第40条：谨慎设计方法签名](#第40条谨慎设计方法签名)
- [第41条：慎用重载](#第41条慎用重载)
- [第42条：慎用可变参数](#第42条慎用可变参数)
- [第43条：返回零长度的数组或集合，而不是null](#第43条返回零长度的数组或集合而不是null)
- [第44条：为所有导出的API元素编写文档注释](#第44条为所有导出的api元素编写文档注释)

---

## 第38条：检查参数的有效性

编写**方法**或者**构造器**的时候，应该考虑它的参数有哪些限制，把限制写到**文档**中，并在方法**开头**检查参数有效性，否则检测错误可能性小，即使检测到，也难以确定错误根源！

* 公有方法使用**显示检查**实施限制
* 非公有方法使用**断言**，如果断言失败会抛`AssertionError`

## 第39条：必要时进行保护性拷贝

如果类具有**从客户端得到**或者**返回客户端**的**可变**组件，类就必须保护性地拷贝这些组件！
1. 构造器：对每个可变参数进行保护性拷贝是必要的，对于参数类型可以被不可信任方子类化的参数，请**不要**使用`clone`方法进行保护性拷贝
2. 访问方法：返回可变内部域的保护性拷贝，**可以**用`clone`，因为内部域类型我们可以限定它不是不可信任方子类化的

**启发**是只要有可能，都应该使用**不可变**的对象作为对象内部组件，例如，存时间时不存`java.util.Date`，它是可变对象，而是存`Date.getTime()`，它返回`long`基本类型，不可变！

如果拷贝的成本受限制，并且类**信任**它的客户端**不会**不恰当地修改组件，就可以在**文档**中指明客户端的职责是不得修改受到影响的组件，以此来代替保护性拷贝！

## 第40条：谨慎设计方法签名

1. 谨慎地选择方法**名称**
2. 不要过于追求提供便利的方法，每个方法应该尽其所能，方法太多使类难以学习、**使用**、**文档化**、**测试**和**维护**
3. **避免过长**的参数列表，目标是小于等于4个，相同类型的长参数序列格外有害，因为不小心弄错参数顺序仍然可以编译运行，难排错

缩短过长的参数列表的方法
1. 把方法**分解**成多个方法，每个方法只需要这些参数的一个子集，不小心方法可能过多，但可通过提升正交性减少方法数
2. 创建**辅助类**，辅助类一般为静态成员类，参数列表升级为辅助类实例参数
3. 从对象构建到方法调用都采用`Builder`模式

注意，对于`boolean`参数，优先使用两个元素的枚举类型！
```Java
public enum TemperatureScale { FAHRENHEIT, CELSIUS }

// Thermometer.newInstance(TemperatureScale.CELSIUS)比Thermometer.newInstance(true)好多了
```

## 第41条：慎用重载

* 重载`Overloading`方法的选择是静态的，是**编译期**的，重载机制是例外
* 覆盖`Override`方法的选择是动态的，是**运行期**的，覆盖机制是规范

**能够**重载方法不意味着**应该**重载方法
1. 安全保守策略是**永远**不要导出两个具有**相同参数数目**的重载方法，如果方法使用**可变参数**，根本**不要**重载它
2. **构造器**等无法避免重载时，应该尽量避免：同一组参数只需经过**类型转换**就可以传给不同重载方法！这使得，自动装箱和泛型出现后，谨慎重载更重要
3. 上述仍无法避免时，应该保证：当传递**同样参数**时，所有重载方法行为必须**一致**

## 第42条：慎用可变参数

**可变参数**：可匹配不同长度的变量！可变参数方法接受**0个或者多个**指定类型的参数！有时候，有必要编写需要1个或者多个某种类型参数的方法，如果客户端调用的同时没有传递参数，它会在**运行时**而不是编译时失败！

* **反射**机制和`printf`都从可变参数中极大受益
* 可变参数方法每次调用都会进行一次数组分配和初始化，影响性能！假设某方法95%概率调用3个或者更少参数，那么可以声明5个重载方法，前4个分别带0、1、2、3个普通参数，当参数数目超过3，就使用一个可变参数方法

## 第43条：返回零长度的数组或集合，而不是null

`null`返回值比零长度数组好，因为它避免了分配数组所需要的开销？**错**！
1. 这个级别上担心性能是不明智的
2. 对于不返回任何元素的调用，每次都返回同一个零长度数组是有可能的

```Java
private final List<Cheese> cheesesInstock = ...;
private static final Cheese[] EMPTY_CHEESE_ARRAY = new Cheese[0];

public Cheese[] getCheeses() {
	// 零长度数组常量被传给toArray方法，以指明所期望的返回类型
	return cheesesInstock.toArray(EMPTY_CHEESE_ARRAY);
}
// cheesesInstock非空时，toArray分配了返回的数组
// cheesesInstock为空时，toArray返回零长度输入数组
// 因为规范保证：如果输入数组大到足够容纳这个集合，它就将返回这个输入数组
```

## 第44条：为所有导出的API元素编写文档注释

为正确编写API文档，必须在每个被导出的**类**、**接口**、**构造器**、**方法**和**域**声明之前增加一个文档注释！

文档注释应该简洁地描述它和客户端之间的约定
1. 说明方法**做了什么**，而不是说明它如何完成
2. 列举方法**所有前提**条件，即为了使客户端能调用该方法而必须满足的条件
3. 列举方法**所有后置**条件，即调用成功后哪些条件必须满足
4. 通常前提由`@throws`针对未受检异常来隐含描述，每个未受检异常都对应一个**前提违例**

文档注释惯例及规范
* `@param`和`@return`后面跟**名词短语**
* `@throws`后面应该包含`if`，然后紧接**名词短语**
* `{@code}`有2个作用：代码片段以**代码字体**呈现，同时**限制**`HTML`标记和嵌套`Javadoc`在片段中处理
* `{@literal}`限制`HTML`标记和嵌套`Javadoc`在片段中处理，但不以代码字体呈现
* 为**泛型**或**方法**编写文档，确保要在文档中说明**所有类型参数**
* 为**枚举**编写文档，确保要在文档中说明**常量**
* 为**注解**编写文档，确保要在文档中说明**所有成员**

文档注释的第一句话通常称为注释所属元素的**概要描述**
1. 同一个类或接口中的两个成员或构造器，**不应该**有同样的概要描述
2. 对于**方法**和**构造器**而言，概要描述是**完整的动词短语**
3. 对于**类**、**接口**和**域**而言，概要描述是**名词短语**
