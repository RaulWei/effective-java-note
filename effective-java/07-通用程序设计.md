# 07-通用程序设计

---

- [第45条：将局部变量的作用域最小化](#第45条将局部变量的作用域最小化)
- [第46条：for-each循环优先于传统的for循环](#第46条for-each循环优先于传统的for循环)
- [第47条：了解和使用类库](#第47条了解和使用类库)
- [第48条：如果需要精确答案，请避免使用float和double](#第48条如果需要精确答案请避免使用float和double)
- [第49条：基本类型优先于装箱基本类型](#第49条基本类型优先于装箱基本类型)
- [第50条：如果其他类型更适合，则尽量避免使用字符串](#第50条如果其他类型更适合则尽量避免使用字符串)
- [第51条：当心字符串连接的性能](#第51条当心字符串连接的性能)
- [第52条：通过接口引用对象](#第52条通过接口引用对象)
- [第53条：接口优先于反射机制](#第53条接口优先于反射机制)
- [第54条：谨慎地使用本地方法](#第54条谨慎地使用本地方法)
- [第55条：谨慎地进行优化](#第55条谨慎地进行优化)
- [第56条：遵守普遍接受的命名惯例](#第56条遵守普遍接受的命名惯例)

---

## 第45条：将局部变量的作用域最小化

1. 在**第一次使用它的地方声明**，过早声明局部变量不仅使它作用域过早扩展，而且结束也过晚
2. 几乎每个**局部变量声明都应该包含一个初始化表达式**，如果没有足够信息进行有意义的初始化就该**推迟**声明
   - `try-catch`相关的特例
   - `for`优于`while`
3. 使方法**小而集中**，如果把两个操作合并到一个方法，与其中一个操作相关的局部变量可能出现在执行另一个操作的代码范围内，为防止这种情况，我们把方法拆成两个，每个方法执行一个操作

## 第46条：for-each循环优先于传统的for循环

`for-each`循环在**简洁性**和**预防Bug**方面有着传统`for`循环无法比拟的优势！

在对多个集合进行嵌套迭代时，`for`容易出错
```Java
enum Suit { CLUB, DIAMOND, HEART, SPADE }
enum Rank { ACE, DEUCE, THREE, FOUR, FIVE, SIX }
Collection<Suit> suits = Arrays.asList(Suit.values());
Collection<Rank> ranks = Arrays.asList(Rank.values());

List<Card> deck = new ArrayList<Card> ();
for (Iterator<Suit> i = suits.iterator(); i.hasNext(); )
	for (Iterator<Rank> j = ranks.iterator(); j.hasNext(); )
		deck.add(new Card(i.next(), j.next()));
```

如果使用`for-each`循环，既没有bug，又简洁
```Java
for (Suit suit: suits)
	for (Rank rank: ranks)
		deck.add(new Card(suit, rank));
```

无法使用`for-each`循环的情况
1. 过滤 - 遍历集合并**删除**选定元素
2. 转换 - 遍历集合并**取代**部分或全部元素值
3. 平行迭代 - 并行地遍历多个集合

## 第47条：了解和使用类库

使用类库的好处
1. 使用标准类库可充分利用前人的专业知识和经验
2. 不必浪费时间为那些与工作**不太相关**的问题提供**特别的解决方案**
3. 类库**性能**往往随时间推移而提高
4. 可使自己的代码**融入主流**，更易读，更易维护，更易被重用

## 第48条：如果需要精确答案，请避免使用float和double

`float`和`double`执行**二进制浮点运算**，在**广泛数值范围提供较为精准的快速近似计算**，**并不精确**！尤其**不适合货币计算**！

想获得精准结果的替代方案
1. `BigDecimal` - 精准，舍入操作可从8种舍入模式择其一，缺点是**使用不方便**和**慢**
2. `int`和`long` - 缺点是**自己处理十进制小数点**

## 第49条：基本类型优先于装箱基本类型

Java**类型系统**由两部分组成：**基本类型**和**引用类型**，每个基本类型对应一个引用类型，称为**装箱基本类型**！

基本类型和装箱基本类型的区别
1. 基本类型只有值，装箱基本类型具有与值不同的**同一性**
2. 基本类型只有功能完备的值，装箱基本类型除此之外还有非功能值`null`
3. 基本类型比装箱基本类型**更节省空间和时间**

装箱基本类型的劣势
1. 用`==`比较两个装箱基本类型时，它会做同一性比较
2. 程序涉及装箱拆箱和基本类型的**混合计算**时，注意拆箱可能抛出`NullPointerException`
3. 程序装箱了基本类型值时会导致**高开销**和不必要的对象创建

装箱基本类型的使用时机
1. 作为**集合**的元素、键和值
2. **泛型**必须使用装箱基本类型作为**参数**

## 第50条：如果其他类型更适合，则尽量避免使用字符串

不应该使用字符串的情形
1. 字符串不适合代替**其他值类型** - 数据从文件、网络进入程序后应该转换为适当的数值类型
2. 字符串不适合代替**枚举**类型
3. 字符串不适合代替**聚集**类型 - 一个实体有多个组件，用一个字符串表示实体通常不合适
4. 字符串不适合代替**能力表** - 设计提供**线程局部变量**，参考`ThreadLocal`

## 第51条：当心字符串连接的性能

字符串不可变，连接两个字符串的时候它们的内容都要被拷贝！连接`n`个字符串而**重复使用字符串连接**操作，时间复杂度为`n`平方级！

解决方案
1. 使用`StringBuilder`
2. 使用字符数组

## 第52条：通过接口引用对象

如果有合适的接口类型存在，对于**参数、返回值、变量和域**，都应该**使用接口**类型声明，而**不是类**！只有利用**构造器创建某个对象**的时候，才真正需要引用这个对象的**类**！通过接口引用对象比较灵活，当**更换实现**时，只需更换构造器名称！

不适合通过接口引用对象的情况
1. 对象属于**基于类的框架**，用**基类**引用对象
2. 类实现接口并提供了接口中不存在的**额外方法**，用**类**引用对象

## 第53条：接口优先于反射机制

核心反射机制的劣势
1. 丧失了**编译时**类型检查、异常检查的好处
2. 执行反射访问所需的**代码笨拙而冗长**，编写乏味，阅读困难
3. **性能损失**，反射调用比普通调用慢了许多

如有可能，就应该仅仅使用反射机制来**实例化**对象，而访问对象时则使用**编译时已知**的某个**接口或者超类**！

## 第54条：谨慎地使用本地方法

本地方法指用**本地程序设计语言如C编写的特殊方法**！`Java Native Interface - JNI`允许Java程序调用本地方法，在本地方法中执行任意计算任务，并返回到Java程序设计语言！

本地方法的优势
1. 访问**特定平台的机制**的能力，如注册表等 - 随着Java平台成熟，提供更多以前只有在宿主才有的特性
2. 访问**遗留代码库**的能力，从而访问遗留数据
3. 通过本地语言编写应用程序中注重性能的部分，以提高系统性能 - 随着JVM越来越快，不使用本地方法也能高性能

本地方法的劣势
1. 本地语言不是安全的，使用本地语言的程序**不能免受内存毁坏错误的影响**
2. 本地语言与平台相关，使用本地语言的程序**不再可移植**
3. 使用本地语言**更难调试**

## 第55条：谨慎地进行优化

1. 不要费力编写快的程序，应编写**结构良好**的程序
2. 设计系统时，特别是**API、线路层协议、永久数据格式**的时候，考虑性能
3. 完成系统构建之后，在**性能剖析器**帮助下，找到需要优化的问题根源

## 第56条：遵守普遍接受的命名惯例

* 类型参数通常由单个字母组成，T任意类型，E**集合元素**类型，KV键值，X异常
* **转换对象类型**的方法，返回不同类型的**独立对象**的方法，通常称为`toType`，如`toString`
* **返回视图**的方法，通常称为`asType`，如`asList`